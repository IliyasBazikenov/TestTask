# Тестовое задание!

Ссылка на тестовое задание:
https://docs.google.com/document/d/1FTf258BYqCpE9rCxNpmQ74bfjX8Hrryd4hdH1yP02g0/edit

Прочитав тестовое задание я выделил цель: **Необходимо добиться атомарности операций бизнес логики обновления полей Bid/Ask объекта Rate и получения их текущего значения. То есть, пока мы получаем значения пары Bid/Ask, никто не может их изменить.**
Как я понял написанное, когда происходит получение значении пары Bid/Ask, данные должны быть консистенты.

# Решения
Хотел бы отметить, что в тестовом задании я нарошно не менял модели, не занимался дополнительным рефакторингом или доработкой исходного кода, не связанного с самим заданием, например не создавал интерфейсы и не делил проект на слои, так как посчитал это лишним.

### ConcurrentDictionary
Суть в том, чтобы использовать thread-safe реализацию словаря в классе **RateStore** вместо обычного Dictionary.  Важно отметить что метод **AddOrUpdate()** класса **ConcurrentDictionary** хоть и thread-safe, но не атомарный и его фабрики-делегаты **addValueFactory/updateValueFactory**  могут быть вызваны много раз.

### ImmutableDictionary
Была идея использовать иммутабельный словарь, но учитывая частые изменения данных, я отказался от этой идеи.

### ReaderWriterLockSlim
Подход  при котороом внутри стора используется **ReaderWriterLockSlim**. При записи ставим монопольный лок или позволяем нескольким потокам производить считывание. Есть подвох, в моем решении, если в будущем придется итерироваться по котировкам **RateStore**, то получим лок, так как используется просто **Dictionary**.

### ConcurrentDictionary with Lazy
Тоже самое что и первый подход, но мы избавляемся от множественных вызовов делегатов **addValueFactory/updateValueFactory**, скорее всего, по скорости и по памяти преимуществ не будет по сравнению с первым подходом.

# Benchmark'и
Использовалась библиотека **BenchmarkDotNet**, для того чтобы измерить производительность выбранных подходов.
Был написан простенький класс **Benchmark**, эмулировалось многопоточность с помощью метода **Parallel.ForEach()**. Замеры проводились на релизной сборке.
Все замеры результатов лежат в папке **BenchmarkDotNet.Artifacts**.
Выводы: какой же выбор оптимальный? Все зависит от того что нам важнее? Если быстродействие то это  **ConcurrentDictionary **, если память то  **ReaderWriterLockSlim **. Так же важно отметить что с ростом размера словаря и количества параллельных операции,  **ConcurrentDictionary ** проседает как по скорости так и по памяти, скорее всего это связано с тем.

